diff -Naurd mpfr-4.1.0-a/PATCHES mpfr-4.1.0-b/PATCHES
--- mpfr-4.1.0-a/PATCHES	2021-05-17 16:09:00.574477185 +0000
+++ mpfr-4.1.0-b/PATCHES	2021-05-17 16:09:00.754476587 +0000
@@ -0,0 +1 @@
+vasprintf-prec-zero
diff -Naurd mpfr-4.1.0-a/VERSION mpfr-4.1.0-b/VERSION
--- mpfr-4.1.0-a/VERSION	2021-04-23 09:49:34.696281616 +0000
+++ mpfr-4.1.0-b/VERSION	2021-05-17 16:09:00.754476587 +0000
@@ -1 +1 @@
-4.1.0-p12
+4.1.0-p13
diff -Naurd mpfr-4.1.0-a/src/mpfr.h mpfr-4.1.0-b/src/mpfr.h
--- mpfr-4.1.0-a/src/mpfr.h	2021-04-23 09:49:34.692281639 +0000
+++ mpfr-4.1.0-b/src/mpfr.h	2021-05-17 16:09:00.754476587 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 4
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "4.1.0-p12"
+#define MPFR_VERSION_STRING "4.1.0-p13"
 
 /* User macros:
    MPFR_USE_FILE:        Define it to make MPFR define functions dealing
diff -Naurd mpfr-4.1.0-a/src/vasprintf.c mpfr-4.1.0-b/src/vasprintf.c
--- mpfr-4.1.0-a/src/vasprintf.c	2021-02-11 12:48:27.354242922 +0000
+++ mpfr-4.1.0-b/src/vasprintf.c	2021-05-17 16:09:00.598477107 +0000
@@ -635,7 +635,13 @@
 static int
 buffer_cat (struct string_buffer *b, const char *s, size_t len)
 {
-  MPFR_ASSERTD (len > 0);
+  /* If len == 0, which is possible when outputting an integer 0
+     (either a native one or mpfr_prec_t) with precision field = 0,
+     do nothing. This test is not necessary since the code below is
+     valid for len == 0, but this is safer, just in case. */
+  if (len == 0)
+    return 0;
+
   MPFR_ASSERTD (len <= strlen (s));
 
   if (buffer_incr_len (b, len))
diff -Naurd mpfr-4.1.0-a/src/version.c mpfr-4.1.0-b/src/version.c
--- mpfr-4.1.0-a/src/version.c	2021-04-23 09:49:34.696281616 +0000
+++ mpfr-4.1.0-b/src/version.c	2021-05-17 16:09:00.754476587 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "4.1.0-p12";
+  return "4.1.0-p13";
 }
diff -Naurd mpfr-4.1.0-a/tests/tsprintf.c mpfr-4.1.0-b/tests/tsprintf.c
--- mpfr-4.1.0-a/tests/tsprintf.c	2020-04-08 22:39:35.000000000 +0000
+++ mpfr-4.1.0-b/tests/tsprintf.c	2021-05-17 16:09:00.598477107 +0000
@@ -193,6 +193,10 @@
   sprintf (buf, "%d", i);
   check_vsprintf (buf, "%d", i);
 
+  check_vsprintf ("0", "%d", 0);
+  check_vsprintf ("", "%.d", 0);
+  check_vsprintf ("", "%.0d", 0);
+
   sprintf (buf, "%e", d);
   check_vsprintf (buf, "%e", d);
 
@@ -227,9 +231,6 @@
   mpfr_prec_t p = 128;
   mpfr_t x, y, z;
 
-  mpfr_init (z);
-  mpfr_init2 (x, p);
-
   /* specifier 'P' for precision */
   check_vsprintf ("128", "%Pu", p);
   check_vsprintf ("00128", "%.5Pu", p);
@@ -247,9 +248,19 @@
   check_vsprintf ("0200:", "%0#+ -Po:", p);
   check_vsprintf ("+0000128 :", "%0+ *.*Pd:", -9, 7, p);
   check_vsprintf ("+12345   :", "%0+ -*.*Pd:", -9, -3, (mpfr_prec_t) 12345);
+  check_vsprintf ("0", "%Pu", (mpfr_prec_t) 0);
   /* Do not add a test like "%05.1Pd" as MS Windows is buggy: when
      a precision is given, the '0' flag must be ignored. */
 
+  /* specifier 'P' with precision field 0 */
+  check_vsprintf ("128", "%.Pu", p);
+  check_vsprintf ("128", "%.0Pd", p);
+  /* check_vsprintf ("", "%.Pu", (mpfr_prec_t) 0); */
+  check_vsprintf ("", "%.0Pd", (mpfr_prec_t) 0);
+
+  mpfr_init (z);
+  mpfr_init2 (x, 128);
+
   /* special numbers */
   mpfr_set_inf (x, 1);
   check_sprintf (pinf_str, "%Re", x);
